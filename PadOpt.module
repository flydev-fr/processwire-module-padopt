<?php
class PadOpt extends WireData implements Module {
  protected $db_padcart = 'padcart';
  protected $db_optcolumn = 'padopt_options';
  protected $field_name = 'padopt_options';
  protected $input_prefix = 'padopt_';
  protected $tpl_prefix = 'padopt_';
  protected $input_padopt_enabled = 'padopt';
  protected $stored_options = array();
  protected $session_id;

  public static function getModuleInfo() {
    return array(
      'title' => 'PadLoper Client Options',
      'version' => 1,
      'summary' => 'Add custom client options to products for PadLoper',
      'icon' => 'cart-plus',
      'href' => 'https://github.com/jvaubourg/processwire-module-padopt',
      'author' => 'Julien Vaubourg',
      'singular' => true,
      'autoload' => true,
      'requires' => 'PadLoper',
    );
  }

  public function init() {
    $this->session_id = session_id();

    $this->addHookBefore('PadLoper::add', $this, 'storeProductOptions');
    $this->addHookAfter('PadCart::addProduct', $this, 'addProductOptionsToCart');
    $this->addHookAfter('PadOrder::parseCart', $this, 'convertCartWithOptionsToOrder');
    $this->addHookAfter('PadProcess::executeViewOrder', $this, 'addOptionsToViewOrder');
  }

  // before PadLoper::add
  public function storeProductOptions($event) {
    $product_id = (int) $event->arguments('id');
    $variation_id = (int) $event->arguments('variation_id');

    $is_padopt_page = ($event->object->input->post($this->input_padopt_enabled) == 1);

    if($is_padopt_page && !empty($product_id) && !empty($variation_id)) {
      if(!array_key_exists($this->session_id, $this->stored_options)) {
        $this->stored_options[$this->session_id] = array();
      }

      if(!array_key_exists($product_id, $this->stored_options[$this->session_id])) {
        $this->stored_options[$this->session_id][$product_id] = array();
      }

      if(!array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {
        $this->stored_options[$this->session_id][$product_id][$variation_id] = array();
      }

      $options = &$this->stored_options[$this->session_id][$product_id][$variation_id];

      foreach($event->object->input->post as $input => $value) {
        if(strpos($input, $this->input_prefix) === 0) {
          // text() allows 255 chars max
          $options[$this->sanitizer->fieldName($input)] = $this->sanitizer->text($value);
        }
      }
    }
  }

  // after PadCart::addProduct
  public function addProductOptionsToCart($event) {
    $product_id = (int) $event->arguments('product_id');
    $variation_id = (int) $event->arguments('variation_id');
    $qty = (int) $event->arguments('qty');

    if($event->return === true && $qty > 0) {
      if(array_key_exists($this->session_id, $this->stored_options)
        && array_key_exists($product_id, $this->stored_options[$this->session_id])
        && array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {

        $cart_row_id = $event->object->checkIfProductInCart($product_id, $variation_id);
  
        if($cart_row_id) {
          $options = $this->stored_options[$this->session_id][$product_id][$variation_id];
          $serialized_options = serialize($options);
  
          $sql = "UPDATE {$this->db_padcart} SET {$this->db_optcolumn} = :options WHERE sess_id = :sess_id AND id = :id";  
          $sth = $this->database->prepare($sql);
          $sth->bindParam(":options", $serialized_options);
          $sth->bindParam(":sess_id", $this->session_id);
          $sth->bindParam(":id", $cart_row_id);
          $sth->execute();

          unset($this->stored_options[$this->session_id][$product_id][$variation_id]);
        }

      } else {
        $this->warning("No options found for the product {$product_id}/{$variation_id} in this session");
      }
    }
  }

  // after PadOrder::parseCart
  public function convertCartWithOptionsToOrder($event) {
    if($event->object->pad_products->count > 0) {
      $sql = "SELECT product_id, variation_id, {$this->db_optcolumn} FROM {$this->db_padcart} WHERE sess_id = :sess_id";
      $sth = $this->database->prepare($sql);
      $sth->bindParam(":sess_id", $this->session_id);
      $sth->execute();

      $cart_products = $sth->fetchAll(\PDO::FETCH_CLASS);

      foreach($cart_products as $cart_product) {
        $product_id = $cart_product->product_id;
        $variation_id = $cart_product->variation_id;

        $order_product = $event->object->pad_products->find("pad_product_id={$product_id}, pad_variation_id={$variation_id}");

        if($order_product->count == 1) {
          $order_product[0]->{$this->field_name} = $cart_product->{$this->db_optcolumn};
          $order_product[0]->save();

        } elseif($order_product->count > 1) {
          $this->warning("Too much products corresponding to {$product_id}/{$variation_id} in the order.");

        } else {
          $this->warning("No product corresponding to {$product_id}/{$variation_id} in the order.");
        }
      }  
    }
  }

  // after PadProcess::executeViewOrder
  public function addOptionsToViewOrder($event) {
    $id = (int) $this->input->get->id;
    $order = $event->object->pages->get($id);
    $page = $event->return;

    preg_match('/<thead>.*<\\/thead>/Us', $page, $thead);
    preg_match('/<tbody>.*<\\/tbody>/Us', $page, $tbody);

    preg_match_all('/<tr>.*<\\/tr>/Us', $tbody[0], $bodyrows);
    $bodyrows = $bodyrows[0];

    if($order->pad_products->count == count($bodyrows) - 1) {
      $headcols = explode('</th>', $thead[0]);
      $headcols[0] .= '</th><th>Included Options';

      $thead = implode('</th>', $headcols);

      for($i = 0; $i < count($bodyrows); $i++) {
        $bodycols = explode('</td>', $bodyrows[$i]);
        $bodycols[0] .= '</td><td>';

        if($i < count($bodyrows) - 1) {
          $serialized_options = $order->pad_products[$i]->{$this->field_name};

          if(!empty($serialized_options)) {
            $options = unserialize($serialized_options);
            $options_list = '<ul>';

            foreach($options as $name => $value) {
              $options_list .= "<li>{$name} : {$value}</li>";
            }

            $options_list .= '</ul>';
            $bodycols[0] .= $options_list;
          }
        }

        $bodyrows[$i] = implode('</td>', $bodycols);
      }

      $tbody = '<tbody>' . implode($bodyrows) . '</tbody>';

      $page = preg_replace('/<thead>.*<\\/thead>/Us', $thead, $page, 1);
      $page = preg_replace('/<tbody>.*<\\/tbody>/Us', $tbody, $page, 1);

      $event->return = $page;

    } else {
      $this->error("Cannot show products options");
    }
  }

  public function getInputPrefix() {
    return $this->input_prefix;
  }

  public function getTplPrefix() {
    return $this->tpl_prefix;
  }

  // Inspired from https://github.com/ryancramerdesign/FormTemplateProcessor
  public function renderFieldset($template) {
    $form = $this->modules->get('InputfieldForm');

    $page = new Page();
    $page->template = $template;
    $fields = $page->getInputfields();
    
    foreach($fields as $field) {
      if(strpos($field->name, $this->input_prefix) === 0) {
        $form->add($field);
      }
    }

    $formRender = $form->render();
    $render = preg_replace('/<\/?form[^>]*>/', '', $formRender);

    return $render;
  }

  public function install() {
    $sql = "ALTER TABLE {$this->db_padcart} ADD {$this->db_optcolumn} TEXT DEFAULT NULL";
    $this->database->exec($sql);

    $this->message("Created new SQL column {$this->db_optcolumn} in carts");

    $padopt_field = new Field();
    $padopt_field->type = $this->modules->get('FieldtypeTextarea');
    $padopt_field->name = $this->field_name;
    $padopt_field->label = 'Order Options for PadLoper';
    $padopt_field->description = 'Options associated to the order, chosen by the client.';
    $padopt_field->save();

    $this->message("Created new field {$padopt_field}");

    $padorder_product = $this->templates->get('padorder_product');
    $padorder_product->fields->add($padopt_field);
    $padorder_product->fields->save();

    $this->message("Added field {$padopt_field} to the padorder_product template");
  }

  public function uninstall() {
    $padorder_product = $this->templates->get('padorder_product');
    $padopt_field = $this->fields->get($this->field_name);
    $padorder_product->fields->remove($padopt_field);
    $padorder_product->fields->save();

    $this->message("Removed field {$padopt_field} from the padorder_product template");

    $this->fields->delete($padopt_field);

    $this->message("Removed field {$padopt_field}");

    $sql = "ALTER TABLE {$this->db_padcart} DROP {$this->db_optcolumn}";
    $this->database->exec($sql);

    $this->message("Dropped SQL column {$this->db_optcolumn} in carts");
  }
}
