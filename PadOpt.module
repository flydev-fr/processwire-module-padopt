<?php

# automatic tagging for fields and templates
# configurator => livecustomization
# use fieldsets for livecustoms
# set random variation_id in hook

class PadOpt extends WireData implements Module {
  protected $db_padcart = 'padcart';
  protected $db_optcolumn = 'padopt_options';
  protected $field_options_name = 'padopt_options';
  protected $field_tpl_name = 'padopt_tpl_id';
  protected $input_padopt_enabled = 'padopt';
  protected $general_input_prefix = 'padopt_';
  protected $input_prefix = 'in_';
  protected $separator_prefix = 'sep_';

  protected $session_id;
  protected $stored_options = array();
  protected $registered_submodules = array();

  public static function getModuleInfo() {
    return array(
      'title' => 'PadLoper Client Options',
      'version' => 1,
      'summary' => 'Add custom client options to products for PadLoper',
      'icon' => 'cart-plus',
      'href' => 'https://github.com/jvaubourg/processwire-module-padopt',
      'author' => 'Julien Vaubourg',
      'singular' => true,
      'autoload' => true,
      'requires' => 'PadLoper',
    );
  }

  public function init() {
    $this->session_id = session_id();
    $this->input_prefix = "{$this->general_input_prefix}{$this->input_prefix}";
    $this->separator_prefix = "{$this->general_input_prefix}{$this->separator_prefix}";

    $this->addHookAfter('ProcessPageEdit::buildForm', $this, 'addTemplateSelect');
    $this->addHookBefore('PadLoper::add', $this, 'storeProductOptions');
    $this->addHookAfter('PadCart::addProduct', $this, 'addProductOptionsToCart');
    $this->addHookAfter('PadOrder::parseCart', $this, 'convertCartWithOptionsToOrder');
    $this->addHookAfter('PadCart::getProductPrice', $this, 'customizePriceWithOptions');
    $this->addHookAfter('Page::render', $this, 'addScriptsAndStyles');
    $this->addHookAfter('PadProcess::executeViewOrder', $this, 'addOptionsToViewOrder');
  }

  // after Page::render
  public function addScriptsAndStyles($event) {
    $page = $event->object; 
    $module_url = $this->config->urls->siteModules . basename(__DIR__);
    
    if($page->template->name == 'admin' && $page->name == 'padloper') {
      $scripts = "<script type='text/javascript' src='{$module_url}/templates/scripts/admin_padloper.js'></script>";
      $styles = "<link type='text/css' href='{$module_url}/templates/styles/admin_padloper.css' rel='stylesheet' />";

      $event->return = str_replace('</head>', "{$styles}{$scripts}</head>", $event->return); 
    }
  }

  // after ProcessPageEdit::buildForm
  public function addTemplateSelect($event) {
    $form = $event->return;
    $inputfield_int_id = $form->getChildByName($this->field_tpl_name);

    if($inputfield_int_id != null) {
      $inputfield_select_tpl = $this->modules->get('InputfieldSelect');

      $inputfield_select_tpl->name = $inputfield_int_id->name;
      $inputfield_select_tpl->label = __("Form");
      $inputfield_select_tpl->description = __("Choose the template you have created for defining the form to display on this page.");

      foreach($this->templates->getAll() as $key => $template) {
        if(!($template->flags & Template::flagSystem)) {
          $inputfield_select_tpl->addOption($key, $template);
        }
      }

      $inputfield_select_tpl->value = $inputfield_int_id->value;
      $form->remove($inputfield_int_id);

      $field_title = $form->getChildByName('title');
      $form->insertAfter($inputfield_select_tpl, $field_title);

      $event->return = $form;
    }
  }

  // before PadLoper::add
  public function storeProductOptions($event) {
    $product_id = (int) $event->arguments('id');
    $variation_id = (int) $event->arguments('variation_id');

    $is_padopt_page = ($event->object->input->post($this->input_padopt_enabled) == 1);

    if($is_padopt_page && !empty($product_id) && !empty($variation_id)) {
      if(!array_key_exists($this->session_id, $this->stored_options)) {
        $this->stored_options[$this->session_id] = array();
      }

      if(!array_key_exists($product_id, $this->stored_options[$this->session_id])) {
        $this->stored_options[$this->session_id][$product_id] = array();
      }

      if(!array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {
        $this->stored_options[$this->session_id][$product_id][$variation_id] = array();
      }

      $options = &$this->stored_options[$this->session_id][$product_id][$variation_id];

      foreach($event->object->input->post as $input => $value) {
        if(strpos($input, $this->general_input_prefix) === 0) {
	  if(is_array($value)) {
            $value = implode('|', $value);
          }

          // text() allows 255 chars max
          $options[$this->sanitizer->fieldName($input)] = $this->sanitizer->text($value);
        }
      }
    }
  }

  // after PadCart::addProduct
  public function addProductOptionsToCart($event) {
    $product_id = (int) $event->arguments('product_id');
    $variation_id = (int) $event->arguments('variation_id');
    $qty = (int) $event->arguments('qty');

    if($event->return === true && $qty > 0) {
      if(array_key_exists($this->session_id, $this->stored_options)
        && array_key_exists($product_id, $this->stored_options[$this->session_id])
        && array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {

        $cart_row_id = $event->object->checkIfProductInCart($product_id, $variation_id);
  
        if($cart_row_id) {
          $options = $this->stored_options[$this->session_id][$product_id][$variation_id];
	  $options['product_id'] = $product_id;
          $serialized_options = serialize($options);
  
          $sql = "UPDATE {$this->db_padcart} SET {$this->db_optcolumn} = :options WHERE sess_id = :sess_id AND id = :id";  
          $sth = $this->database->prepare($sql);
          $sth->bindParam(":options", $serialized_options);
          $sth->bindParam(":sess_id", $this->session_id);
          $sth->bindParam(":id", $cart_row_id);
          $sth->execute();

          unset($this->stored_options[$this->session_id][$product_id][$variation_id]);
        }

      } else {
        $this->warning("No options found for the product {$product_id}/{$variation_id} in this session");
      }
    }
  }

  // after PadOrder::parseCart
  public function convertCartWithOptionsToOrder($event) {
    if($event->object->pad_products->count > 0) {
      $sql = "SELECT product_id, variation_id, {$this->db_optcolumn} FROM {$this->db_padcart} WHERE sess_id = :sess_id";
      $sth = $this->database->prepare($sql);
      $sth->bindParam(":sess_id", $this->session_id);
      $sth->execute();

      $cart_products = $sth->fetchAll(\PDO::FETCH_CLASS);

      foreach($cart_products as $cart_product) {
        $product_id = $cart_product->product_id;
        $variation_id = $cart_product->variation_id;

        $order_product = $event->object->pad_products->find("pad_product_id={$product_id}, pad_variation_id={$variation_id}");

        if($order_product->count == 1) {
          $order_product[0]->{$this->field_options_name} = $cart_product->{$this->db_optcolumn};
          $order_product[0]->save();

        } elseif($order_product->count > 1) {
          $this->warning("Too much products corresponding to {$product_id}/{$variation_id} in the order.");

        } else {
          $this->warning("No product corresponding to {$product_id}/{$variation_id} in the order.");
        }
      }  
    }
  }

  // after PadCart::getProductPrice
  public function customizePriceWithOptions($event) {

  }

  private function renderOptionsHtml($options) {
    $options_list = '<ul class="padopt_included_options">';

    foreach($options as $name => $value) {
      if($name != 'product_id') {
        $field_label = $this->fields->get($name)->label;
        $field_options = $this->fields->get($name)->type->getOptions($this->fields->get($name));

        if(strpos($value, '|') !== false) {
          $subvalues = explode('|', $value);
          $field_txt = '<ul>';

          foreach($subvalues as $subvalue) {
            $field_txt .= "<li><em>{$field_options->get($subvalue)->data['title']}</em></li>";
          }

          $field_txt .= '</ul>';

        } else {
          $field_txt = "<em>{$field_options->get($value)->data['title']}</em>";
        }

        $options_list .= "<li><strong>{$field_label}:</strong> {$field_txt}</li>";
      }
    }

    $options_list .= '</ul>';

    $product_id = $options['product_id'];
    $json_options = json_encode($options);
    $url_options = urlencode($json_options);
    $view_url = "{$this->pages->get($product_id)->url}#{$url_options}";

    $view_buttons = "<a href='{$view_url}' target='_blank'>" . __("View online") . '</a><br />';
    $view_buttons .= "<a href='javascript:;' class='padopt_show_options'>" . __("Show list") . '</a>';

    return $view_buttons.$options_list;
  }


  // after PadProcess::executeViewOrder
  public function addOptionsToViewOrder($event) {
    $id = (int) $this->input->get->id;
    $order = $event->object->pages->get($id);
    $page = $event->return;

    preg_match('/<thead>.*<\\/thead>/Us', $page, $thead);
    preg_match('/<tbody>.*<\\/tbody>/Us', $page, $tbody);

    preg_match_all('/<tr>.*<\\/tr>/Us', $tbody[0], $bodyrows);
    $bodyrows = $bodyrows[0];

    if($order->pad_products->count == count($bodyrows) - 1) {
      $headcols = explode('</th>', $thead[0]);
      $headcols[0] .= '</th><th>' . __("Included Options");

      $thead = implode('</th>', $headcols);

      for($i = 0; $i < count($bodyrows); $i++) {
        $bodycols = explode('</td>', $bodyrows[$i]);
        $bodycols[0] .= '</td><td>';

        if($i < count($bodyrows) - 1) {
          $serialized_options = $order->pad_products[$i]->{$this->field_options_name};

          if(!empty($serialized_options)) {
            $options = unserialize($serialized_options);
            $bodycols[0] .= $this->renderOptionsHtml($options);
          }
        }

        $bodyrows[$i] = implode('</td>', $bodycols);
      }

      $tbody = '<tbody>' . implode($bodyrows) . '</tbody>';

      $page = preg_replace('/<thead>.*<\\/thead>/Us', $thead, $page, 1);
      $page = preg_replace('/<tbody>.*<\\/tbody>/Us', $tbody, $page, 1);

      $event->return = $page;

    } else {
      $this->error("Cannot show products options");
    }
  }

  public function registerSubmodule($submodule) {
    $input_prefix = $submodule->getInputPrefix();
    $this->registered_submodules["{$this->general_input_prefix}{$input_prefix}"] = $submodule;
  }

  public function getFieldTplName() {
    return $this->field_tpl_name;
  }

  public function getInputPrefix() {
    return $this->input_prefix;
  }

  public function getGeneralInputPrefix() {
    return $this->general_input_prefix;
  }

  public function renderFieldset() {
    $template = $this->templates->get($this->page->get($this->field_tpl_name));

    $page = new Page();
    $page->template = $template;
    $inputfields = $page->getInputfields();

    $inputfield_groups = array();
    $inputfield_groups_id = 0;
    
    foreach($inputfields as $inputfield) {
      preg_match("/^{$this->general_input_prefix}[^_]+_/", $inputfield->name, $prefix);

      if(!empty($prefix)) {
        $prefix = $prefix[0];

        if(empty($inputfield_groups)) {
          $inputfield_groups[] = array(
            'prefix' => $prefix,
            'inputfields' => array($inputfield),
          );

        } else {
          if($inputfield_groups[$inputfield_groups_id]['prefix'] == $prefix) {
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;

          } else {
            $inputfield_groups_id++;
            $inputfield_groups[$inputfield_groups_id]['prefix'] = $prefix;
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;
          }
        }
      }
    }

    $render = '';

    foreach($inputfield_groups as $inputfield_group) {
      if($inputfield_group['prefix'] == $this->separator_prefix) {
        $separator = "<h2>{$inputfield_group['inputfields'][0]->label}</h2>";

	if(!empty($inputfield->description)) {
          $separator .= "<div>{$inputfield_group['inputfields'][0]->description}</div>";
        }

	if(!empty($inputfield->notes)) {
          $separator .= "<div>{$inputfield_group['inputfields'][0]->notes}</div>";
        }

        $render .= $separator;

      } elseif($inputfield_group['prefix'] == $this->input_prefix) {
        $form = $this->modules->get('InputfieldForm');

        foreach($inputfield_group['inputfields'] as $inputfield) {
          $form->add($inputfield);
        }

        $form_render = $form->render();
        $render .= preg_replace('/<\/?form[^>]*>/', '', $form_render);

      } elseif(isset($this->registered_submodules[$inputfield_group['prefix']])) {
        $render .= $this->registered_submodules[$inputfield_group['prefix']]->render($inputfield_group['inputfields']);
      }
    }

    return $render;
  }

  public function renderCartOptions($product) {
    $sql = "SELECT {$this->db_optcolumn} FROM {$this->db_padcart} WHERE product_id = :product_id AND variation_id = :variation_id AND sess_id = :sess_id LIMIT 1";
    $sth = $this->database->prepare($sql);
    $sth->bindParam(":product_id", $product->product_id);
    $sth->bindParam(":variation_id", $product->variation_id);
    $sth->bindParam(":sess_id", $this->session_id);
    $sth->execute();

    $serialized_options = $sth->fetchAll(\PDO::FETCH_CLASS);
    $serialized_options = $serialized_options[0];
    $options = unserialize($serialized_options->{$this->db_optcolumn});
    $json_options = json_encode($options);
    $url_options = urlencode($json_options);

    $view_url = "{$this->pages->get($product->product_id)->url}#{$url_options}";
    $view_link = "<a href='{$view_url}' target='_blank'>" . __('With options') . '</a>';
    
    return $view_link;
  }

  public function install() {
    $sql = "ALTER TABLE {$this->db_padcart} ADD {$this->db_optcolumn} TEXT DEFAULT NULL";
    $this->database->exec($sql);

    $this->message("Created new SQL column {$this->db_optcolumn} in carts");

    $field_tpl = new Field();
    $field_tpl->type = $this->modules->get('FieldtypeInteger');
    $field_tpl->name = $this->field_tpl_name;
    $field_tpl->label = 'Form Template Id for PadOpt pages';
    $field_tpl->description = 'Id of the template to use to build the options form in PadOpt pages.';
    $field_tpl->save();

    $this->message("Created new field {$field_tpl}");

    $field_options = new Field();
    $field_options->type = $this->modules->get('FieldtypeTextarea');
    $field_options->name = $this->field_options_name;
    $field_options->label = 'Order Options for PadLoper';
    $field_options->description = 'Options associated to the order, chosen by the client.';
    $field_options->save();

    $this->message("Created new field {$field_options}");

    $padorder_product = $this->templates->get('padorder_product');
    $padorder_product->fields->add($field_options);
    $padorder_product->fields->save();

    $this->message("Added field {$field_options} to the padorder_product template");
  }

  public function uninstall() {
    $padorder_product = $this->templates->get('padorder_product');
    $field_options = $this->fields->get($this->field_options_name);
    $padorder_product->fields->remove($field_options);
    $padorder_product->fields->save();

    $this->message("Removed field {$field_options} from the padorder_product template");

    $this->fields->delete($field_options);
    $this->message("Removed field {$field_options}");

    $field_tpl = $this->fields->get($this->field_tpl_name);
    $this->fields->delete($field_tpl);
    $this->message("Removed field {$field_tpl}");

    $sql = "ALTER TABLE {$this->db_padcart} DROP {$this->db_optcolumn}";
    $this->database->exec($sql);

    $this->message("Dropped SQL column {$this->db_optcolumn} in carts");
  }
}
