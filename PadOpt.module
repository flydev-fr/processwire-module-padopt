<?php

class PadOpt extends WireData implements Module {
  protected $db_padcart = 'padcart';
  protected $db_optcolumn = 'padopt_options';
  protected $field_options_name = 'padopt_options';
  protected $field_tpl_name = 'padopt_tpl_id';
  protected $input_padopt_enabled = 'padopt';
  protected $tag_name = 'padopt';
  protected $general_input_prefix = 'padopt_';
  protected $input_prefix = 'input_';
  protected $separator_prefix = 'sep_';

  protected $session_id;
  protected $stored_options = array();
  protected $registered_submodules = array();

  public static function getModuleInfo() {
    return array(
      'title' => 'PadLoper Client Options',
      'version' => 1,
      'summary' => 'Add custom client options to products for PadLoper',
      'icon' => 'cart-plus',
      'href' => 'https://github.com/jvaubourg/processwire-module-padopt',
      'author' => 'Julien Vaubourg',
      'singular' => true,
      'autoload' => true,
      'requires' => 'PadLoper',
    );
  }

  public function init() {
    $this->session_id = session_id();
    $this->input_prefix = "{$this->general_input_prefix}{$this->input_prefix}";
    $this->separator_prefix = "{$this->general_input_prefix}{$this->separator_prefix}";

    $this->addHookBefore('ProcessField::executeSave', $this, 'automaticTagging');
    $this->addHookBefore('ProcessTemplate::executeSave', $this, 'automaticTagging');
    $this->addHookAfter('ProcessPageEdit::buildForm', $this, 'addTemplateSelect');
    $this->addHookBefore('PadLoper::add', $this, 'storeProductOptions');
    $this->addHookAfter('PadCart::addProduct', $this, 'addProductOptionsToCart');
    $this->addHookAfter('PadOrder::parseCart', $this, 'convertCartWithOptionsToOrder');
    $this->addHookAfter('PadCart::getProductPrice', $this, 'customizePriceWithOptions');
    $this->addHookAfter('Page::render', $this, 'addScriptsAndStyles');
    $this->addHookAfter('PadProcess::executeViewOrder', $this, 'addOptionsToViewOrder');
  }


  /***********/
  /** HOOKS **/
  /***********/

  /**
   * Automatically add a <tag_name> tag to every new field and template created
   * with a name beginning by <general_input_prefix>
   * Act before ProcessField::executeSave and ProcessTemplate::executeSave
   */
  public function automaticTagging($event) {
    $post_values = $event->object->input->post;

    if((($post_values['name'] && strpos($post_values['name'], $this->general_input_prefix) === 0)
        || ($post_values['rename'] && strpos($post_values['rename'], $this->general_input_prefix) === 0))
      && strpos($post_values['tags'], $this->tag_name) === false) {

      $post_values['tags'] .= " {$this->tag_name}";
    }
  }

  /**
   * Add some JS and css in the header of every page of the PadLoper admin
   * Act before Page::render
   */
  public function addScriptsAndStyles($event) {
    $page = $event->object; 
    $module_url = $this->config->urls->siteModules . basename(__DIR__);
    
    // Only for PadLoper admin pages
    if($page->template->name == 'admin' && $page->name == 'padloper') {
      $scripts = "<script type='text/javascript' src='{$module_url}/templates/scripts/admin_padloper.js'></script>";
      $styles = "<link type='text/css' href='{$module_url}/templates/styles/admin_padloper.css' rel='stylesheet' />";

      $event->return = str_replace('</head>', "{$styles}{$scripts}</head>", $event->return); 
    }
  }

  /**
   * When an admin page is edited, replace the field named <field_tpl_name>
   * (simple input text for integers) by a select proposing to chose one of
   * the template available in PW. This is used when a PadOpt product page
   * is edited
   * Act after ProcessPageEdit::buildForm
   */
  public function addTemplateSelect($event) {
    $form = $event->return;
    $inputfield_int_id = $form->getChildByName($this->field_tpl_name);

    // Only pages proposing the target field (ie. PadOpt product pages)
    if($inputfield_int_id != null) {
      $inputfield_select_tpl = $this->modules->get('InputfieldSelect');

      $inputfield_select_tpl->name = $inputfield_int_id->name;
      $inputfield_select_tpl->label = __("Form");
      $inputfield_select_tpl->description = __("Choose the template you have created for defining the form to display on this page.");

      // Build a select with all available non-system templates in PW
      foreach($this->templates->getAll() as $key => $template) {
        if(!($template->flags & Template::flagSystem)) {
          $inputfield_select_tpl->addOption($key, $template);
        }
      }

      // The input text version of the field is removed
      $inputfield_select_tpl->value = $inputfield_int_id->value;
      $form->remove($inputfield_int_id);

      // ... and replaced by the new version with values to select
      $field_title = $form->getChildByName('title');
      $form->insertAfter($inputfield_select_tpl, $field_title);

      $event->return = $form;
    }
  }

  /**
   * Catch the value of every input field with a name beginning by
   * <general_input_prefix>, among the values transmitted by a page to PadLoper,
   * when an "Add to Cart" button is pushed. These values (describing product
   * options) are temporarily stored in an array, to be used later by
   * addProductOptionsToCart
   * Act before PadLoper::add
   */
  public function storeProductOptions($event) {
    $product_id = (int) $event->arguments('id');
    $variation_id = (int) $event->arguments('variation_id');

    // Only for pages containing an input field named <input_padopt_enabled>
    $is_padopt_page = ($event->object->input->post($this->input_padopt_enabled) == 1);

    if($is_padopt_page && !empty($product_id) && !empty($variation_id)) {
      if(!array_key_exists($this->session_id, $this->stored_options)) {
        $this->stored_options[$this->session_id] = array();
      }

      if(!array_key_exists($product_id, $this->stored_options[$this->session_id])) {
        $this->stored_options[$this->session_id][$product_id] = array();
      }

      if(!array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {
        $this->stored_options[$this->session_id][$product_id][$variation_id] = array();
      }

      $options = &$this->stored_options[$this->session_id][$product_id][$variation_id];

      // Input values are stored only when the name begins with
      // <general_input_prefix>, corresponding to input fields generated
      // by PadOpt
      foreach($event->object->input->post as $input => $value) {
        if(strpos($input, $this->general_input_prefix) === 0) {

          // Values composed of multiple values (eg. checkboxes) are concatenated
          // into a single value (eg. 1|2|3)
	  if(is_array($value)) {
            $value = implode('|', $value);
          }

          // Warn: text() allows 255 chars max
          $options[$this->sanitizer->fieldName($input)] = $this->sanitizer->text($value);
        }
      }
    }
  }

  /**
   * Store in db the options associated to the product to add to the cart. The
   * values are serialized and saved in the <db_optcolumn> MySQL column of the
   * tuple, created for the current cart by PadLoper in the hooked function
   * Act after PadCart::addProduct
   */
  public function addProductOptionsToCart($event) {
    $product_id = (int) $event->arguments('product_id');
    $variation_id = (int) $event->arguments('variation_id');
    $qty = (int) $event->arguments('qty');

    // Only if the hooked function worked well (ie. the cart was well created in the db)
    if($event->return === true && $qty > 0) {

      // If storeProductOptions found earlier some options values to store for this product
      if(array_key_exists($this->session_id, $this->stored_options)
        && array_key_exists($product_id, $this->stored_options[$this->session_id])
        && array_key_exists($variation_id, $this->stored_options[$this->session_id][$product_id])) {

        // Get the id of the cart-product tuple in the db
        $cart_row_id = $event->object->checkIfProductInCart($product_id, $variation_id);
  
        if($cart_row_id) {
          $options = $this->stored_options[$this->session_id][$product_id][$variation_id];
	  $options['product_id'] = $product_id;
          $serialized_options = serialize($options);
  
          // Fill the <db_optcolumn> with all the option values associated to
          // this product when added in the cart by the client
          $sql = "UPDATE {$this->db_padcart} SET {$this->db_optcolumn} = :options WHERE sess_id = :sess_id AND id = :id";  
          $sth = $this->database->prepare($sql);
          $sth->bindParam(":options", $serialized_options);
          $sth->bindParam(":sess_id", $this->session_id);
          $sth->bindParam(":id", $cart_row_id);
          $sth->execute();

          // Free the temporary memory allocated for jumping from storeProductOptions
          // (values catching) to addProductOptionsToCart (values injecting)
          unset($this->stored_options[$this->session_id][$product_id][$variation_id]);
        }
      }
    }
  }

  /**
   * Move the product options stored into a db column when added to a cart, to
   * a PW field, when the cart is converted to an order (the order pad_product
   * page is created during the hooked function, and the db tuple is deleted
   * just after)
   * Act after PadOrder::parseCart
   */
  public function convertCartWithOptionsToOrder($event) {
    if($event->object->pad_products->count > 0) {

      // Get the options associated to this product and stored by addProductOptionsToCart
      $sql = "SELECT product_id, variation_id, {$this->db_optcolumn} FROM {$this->db_padcart} WHERE sess_id = :sess_id";
      $sth = $this->database->prepare($sql);
      $sth->bindParam(":sess_id", $this->session_id);
      $sth->execute();

      $cart_products = $sth->fetchAll(\PDO::FETCH_CLASS);

      foreach($cart_products as $cart_product) {

        // Only if this product was added with PadOpt options
        if(!empty($cart_product->{$this->db_optcolumn})) {
          $product_id = $cart_product->product_id;
          $variation_id = $cart_product->variation_id;

          // Get the pad_product page created for this product in the hooked function
          $order_product = $event->object->pad_products->find("pad_product_id={$product_id}, pad_variation_id={$variation_id}");

          if($order_product->count == 1) {
            $order_product[0]->{$this->field_options_name} = $cart_product->{$this->db_optcolumn};
            $order_product[0]->save();

          } elseif($order_product->count > 1) {
            $this->warning("Too much products corresponding to {$product_id}/{$variation_id} in the order.");

          } else {
            $this->warning("No product corresponding to {$product_id}/{$variation_id} in the order.");
          }
        }
      }
    }
  }

  /**
   * Add the price of the chosen paid options to the the initial price of the
   * product. Used when displaying the cart, for the client-side order
   * summaries, invoices, and to definitely store the final prices in the orders
   * Act after PadCart::getProductPrice
   */
  public function customizePriceWithOptions($event) {
    $product = $event->arguments('product');
    $product_id = $product->id;
    $variation_id = $event->arguments('variation_id');
    $pricefield = $event->object->pricefield;
    $price = (float) $product->$pricefield;

    $options = $this->getCartProductOptions($product_id, $variation_id);
    $options_price = (float) $this->getCartProductOptionsPrice($options);

    $event->return = $price + $options_price;
  }

  /**
   * Change the admin-side order summary views, by injecting new HTML table
   * columns describing the options associated by clients to the products durant
   * their shoppings.
   * Act after PadProcess::executeViewOrder
   */
  public function addOptionsToViewOrder($event) {
    $id = (int) $this->input->get->id;
    $order = $event->object->pages->get($id);
    $page = $event->return;

    preg_match('/<thead>.*<\\/thead>/Us', $page, $thead);
    preg_match('/<tbody>.*<\\/tbody>/Us', $page, $tbody);

    preg_match_all('/<tr>.*<\\/tr>/Us', $tbody[0], $bodyrows);
    $bodyrows = $bodyrows[0];

    // The HTML table of the current view should has as many lines as there are
    // products associated to the order (+ 1 at the end)
    if($order->pad_products->count == count($bodyrows) - 1) {
      $headcols = explode('</th>', $thead[0]);
      $headcols[0] .= '</th><th>' . __("Included Options");

      $thead = implode('</th>', $headcols);

      for($i = 0; $i < count($bodyrows); $i++) {
        $bodycols = explode('</td>', $bodyrows[$i]);
        $bodycols[0] .= '</td><td>';

        // The last line corresponds to the total price of the order
        if($i < count($bodyrows) - 1) {
          $serialized_options = $order->pad_products[$i]->{$this->field_options_name};

          if(!empty($serialized_options)) {
            $options = unserialize($serialized_options);
            $options_list = $this->renderOptionsHtml($options);

            $product_id = $options['product_id'];
            $json_options = json_encode($options);
            $url_options = base64_encode($json_options);
            $view_url = "{$this->pages->get($product_id)->url}#{$url_options}";
        
            $view_buttons = "<a href='{$view_url}' target='_blank'>" . __("View online") . '</a><br />';
            $view_buttons .= "<a href='javascript:;' class='padopt_show_options'>" . __("Show list") . '</a>';

            $bodycols[0] .= $view_buttons.$options_list;
          }
        }

        $bodyrows[$i] = implode('</td>', $bodycols);
      }

      $tbody = '<tbody>' . implode($bodyrows) . '</tbody>';

      $page = preg_replace('/<thead>.*<\\/thead>/Us', $thead, $page, 1);
      $page = preg_replace('/<tbody>.*<\\/tbody>/Us', $tbody, $page, 1);

      $event->return = $page;

    } else {
      $this->error("Cannot show products options");
    }
  }


  /***********************/
  /** PRIVATE FUNCTIONS **/
  /***********************/

  /**
   * Produce the HTML code corresponding to the options list associated to a
   * product
   *
   * @param 
   */
  private function renderOptionsHtml($options) {
    $options_list = '<ul class="padopt_included_options">';

    foreach($options as $name => $value) {
      if($name != 'product_id') {
        $field_label = $this->fields->get($name)->label;
        $field_options = $this->fields->get($name)->type->getOptions($this->fields->get($name));
        $field_txt = '';

        if(empty($field_options)) {
          $field_txt = "<em>$value</em>";

        } else {
          if(strpos($value, '|') !== false) {
            $subvalues = explode('|', $value);
            $field_txt = '<ul>';
  
            foreach($subvalues as $subvalue) {
              $field_txt .= "<li><em>{$field_options->get($subvalue)->data['title']}</em></li>";
            }
  
            $field_txt .= '</ul>';
  
          } else {
            if(!empty($value)) {
              $field_txt = "<em>{$field_options->get($value)->data['title']}</em>";
            }
          }
        }

        $options_list .= "<li><strong>{$field_label}:</strong> {$field_txt}</li>";
      }
    }

    $options_list .= '</ul>';

    return $options_list;
  }

  public function registerSubmodule($submodule) {
    $input_prefix = $submodule->getInputPrefix();
    $this->registered_submodules["{$this->general_input_prefix}{$input_prefix}"] = $submodule;
  }

  public function getFieldTplName() {
    return $this->field_tpl_name;
  }

  public function getInputPrefix() {
    return $this->input_prefix;
  }

  public function getGeneralInputPrefix() {
    return $this->general_input_prefix;
  }

  public function renderFieldset() {
    $template = $this->templates->get($this->page->get($this->field_tpl_name));

    $page = new Page();
    $page->template = $template;
    $inputfields = $page->getInputfields();

    $inputfield_groups = array();
    $inputfield_groups_id = 0;
    
    foreach($inputfields as $inputfield) {
      preg_match("/^{$this->general_input_prefix}[^_]+_/", $inputfield->name, $prefix);

      if(!empty($prefix)) {
        $prefix = $prefix[0];

        if(empty($inputfield_groups)) {
          $inputfield_groups[] = array(
            'prefix' => $prefix,
            'inputfields' => array($inputfield),
          );

        } else {
          if($inputfield_groups[$inputfield_groups_id]['prefix'] == $prefix) {
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;

          } else {
            $inputfield_groups_id++;
            $inputfield_groups[$inputfield_groups_id]['prefix'] = $prefix;
            $inputfield_groups[$inputfield_groups_id]['inputfields'][] = $inputfield;
          }
        }
      }
    }

    $render = "<input type='hidden' name='padopt' value='1' />";
    $render .= "<input type='hidden' name='variation_id' value='" . rand(100000, 1000000) . "' />";
    $render .= "<input type='hidden' name='product_id' value='{$this->page->id}' />";

    foreach($inputfield_groups as $inputfield_group) {
      if($inputfield_group['prefix'] == $this->separator_prefix) {
        $separator = "<h2>{$inputfield_group['inputfields'][0]->label}</h2>";

	if(!empty($inputfield->description)) {
          $separator .= "<div>{$inputfield_group['inputfields'][0]->description}</div>";
        }

	if(!empty($inputfield->notes)) {
          $separator .= "<div>{$inputfield_group['inputfields'][0]->notes}</div>";
        }

        $render .= $separator;

      } elseif($inputfield_group['prefix'] == $this->input_prefix) {
        $form = $this->modules->get('InputfieldForm');

        foreach($inputfield_group['inputfields'] as $inputfield) {
          $form->add($inputfield);
        }

        $form_render = $form->render();
        $render .= preg_replace('/<\/?form[^>]*>/', '', $form_render);

      } elseif(isset($this->registered_submodules[$inputfield_group['prefix']])) {
        $render .= $this->registered_submodules[$inputfield_group['prefix']]->render($inputfield_group['inputfields']);
      }
    }

    return $render;
  }

  private function getCartProductOptions($product_id, $variation_id) {
    $sql = "SELECT {$this->db_optcolumn} FROM {$this->db_padcart} WHERE product_id = :product_id AND variation_id = :variation_id AND sess_id = :sess_id LIMIT 1";
    $sth = $this->database->prepare($sql);
    $sth->bindParam(":product_id", $product_id);
    $sth->bindParam(":variation_id", $variation_id);
    $sth->bindParam(":sess_id", $this->session_id);
    $sth->execute();

    $serialized_options = $sth->fetchAll(\PDO::FETCH_CLASS);
    $serialized_options = $serialized_options[0];
    $options = unserialize($serialized_options->{$this->db_optcolumn});

    return $options;
  }

  private function extractOptionPriceFromTitle($title) {
    $option_price = 0;

    preg_match('/\+\s*\(\s*([0-9]+(?:[.,][0-9]+)?)\s*.+\s*\)/', $title, $matches);

    if(count($matches) > 1) {
      $option_price = $matches[1];
    }

    return $option_price;
  }

  private function getCartProductOptionsPrice($options) {
    $options_price = 0;

    foreach($options as $name => $value) {
      if($name != 'product_id') {
        $field_options = $this->fields->get($name)->type->getOptions($this->fields->get($name));
  
        if(!empty($field_options)) {
          if(strpos($value, '|') !== false) {
            $subvalues = explode('|', $value);
    
            foreach($subvalues as $subvalue) {
              $options_price += $this->extractOptionPriceFromTitle($field_options->get($subvalue)->data['title']);
            }
    
          } else {
            if($value != '') {
              $options_price += $this->extractOptionPriceFromTitle($field_options->get($value)->data['title']);
            }
          }
        }
      }
    }

    return $options_price;
  }

  public function getCartProductOptionsInfos($product) {
    $options = $this->getCartProductOptions($product->product_id, $product->variation_id);
    $view_link = '';
    $options_list = '';
    $options_price = '';

    if(!empty($options)) {
      $json_options = json_encode($options);
      $url_options = base64_encode($json_options);
  
      $view_url = "{$this->pages->get($product->product_id)->url}#{$url_options}";
      $options_list = $this->renderOptionsHtml($options);
      $options_price = $this->getCartProductOptionsPrice($options);
    }

    $infos = array($view_url, $options_list, $options_price);
    
    return $infos;
  }

  public function install() {
    $sql = "ALTER TABLE {$this->db_padcart} ADD {$this->db_optcolumn} TEXT DEFAULT NULL";
    $this->database->exec($sql);

    $this->message("Created new SQL column {$this->db_optcolumn} in carts");

    $field_tpl = new Field();
    $field_tpl->type = $this->modules->get('FieldtypeInteger');
    $field_tpl->name = $this->field_tpl_name;
    $field_tpl->label = 'Form Template Id for PadOpt pages';
    $field_tpl->description = 'Id of the template to use to build the options form in PadOpt pages.';
    $field_tpl->save();

    $this->message("Created new field {$field_tpl}");

    $field_options = new Field();
    $field_options->type = $this->modules->get('FieldtypeTextarea');
    $field_options->name = $this->field_options_name;
    $field_options->label = 'Order Options for PadLoper';
    $field_options->description = 'Options associated to the order, chosen by the client.';
    $field_options->save();

    $this->message("Created new field {$field_options}");

    $padorder_product = $this->templates->get('padorder_product');
    $padorder_product->fields->add($field_options);
    $padorder_product->fields->save();

    $this->message("Added field {$field_options} to the padorder_product template");
  }

  public function uninstall() {
    $padorder_product = $this->templates->get('padorder_product');
    $field_options = $this->fields->get($this->field_options_name);
    $padorder_product->fields->remove($field_options);
    $padorder_product->fields->save();

    $this->message("Removed field {$field_options} from the padorder_product template");

    $this->fields->delete($field_options);
    $this->message("Removed field {$field_options}");

    $field_tpl = $this->fields->get($this->field_tpl_name);
    $this->fields->delete($field_tpl);
    $this->message("Removed field {$field_tpl}");

    $sql = "ALTER TABLE {$this->db_padcart} DROP {$this->db_optcolumn}";
    $this->database->exec($sql);

    $this->message("Dropped SQL column {$this->db_optcolumn} in carts");
  }
}
